#!/usr/bin/racket
#lang racket

(define (max-list-v1 nums)
    (cond 
        [(empty? (rest nums)) (first nums)]
        [else (max (first nums) (max-list-v1 (rest nums)))]
    )
)


(define (max-list-v2 nums)
    (cond
        [(empty? (rest nums)) (first nums)]
        [(> (first nums))]
    )
)


(define (reverse-a x)
    (cond 
        [(empty? (rest x)) (list (first x))]
        [else (append (reverse (rest x)) (list (first x)))]
    )
)

;;; (reverse-a '(3 4 5 3 2 3 4 9 8))

(define (fib n)
    (cond 
        [(< n 2) n]
        [else (+ (fib (- n 1)) (fib (- n 2)))]
        )
)

;;; (define (fiba n)
;;;     (cond
;;;         [(= 1) 1]
;;;         []
;;;     )
;;; )


;;;  (extend-fib n lst) that consumes a Nat and a (listof Nat). Given
;;; lst, a list containing at least 2 Fibonacci values in non-increasing order, it returns a list
;;; containing n more Fibonacci values.


;;; (define (fib-helper n acc)
;;;   (if (= n 1) (first acc) (fib-helper (- n 1) (cons (+ (first acc) (first (rest acc))) acc)) ))

;;; (define (fib-n n) (if (= n 0) 0 (fib-helper n (list 1 0))))

;;; (fib-helper 10 0)

(define (fib-helper n acc)
    (cond 
        [(< n 2) acc]
        [else (fib-helper (sub1 n) (cons (+ (first acc) (second acc)) acc))]
    )
)

(define (fiba n) (first (fib-helper n (list 0 1))))

;;; (fiba 5)

(define (mean x)
    (mean/acc x 0 0)
)

(define (mean/acc x acc n)
    (cond
        [(empty? x) (/ acc n)]
        [else (mean/acc (rest x) (+ acc (first x)) (add1 n))]
    )
)

(mean (list 1 2))


